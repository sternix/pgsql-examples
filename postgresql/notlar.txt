--bad
DECLARE v varchar;
BEGIN
  v := 'a';
  v := v || 'b';
  v := v || 'c';
  RETURN v;
END;

--well
BEGIN
  RETURN 'a' || 'b' || 'c';
END;

---------8<--------------------------

-- bad
DECLARE s varchar := '';
BEGIN
  IF x1 IS NULL THEN
    s := s || 'NULL,'
  ELSE
    s := s || x1;
  END IF;

  IF x2 IS NULL THEN
    s := s || 'NULL, '
  ELSE
    s := s || x2;
  END IF;
  ...

-- well
DECLARE s varchar;
BEGIN
  s := COALESCE(x1 || ',', 'NULL,')
       || COALESCE(x2 || ',', 'NULL,')
  ...

---------8<--------------------------

--bad
CREATE OR REPLACE FUNCTION last_day(IN d date)
RETURNS date AS $$
BEGIN
  RETURN CAST(date_trunc('month',current_date + interval '1month') AS date) - 1;
END;
$$ LANGUAGE plpgsql IMMUTABLE STRICT;

--well
CREATE OR REPLACE FUNCTION last_day(IN d date)
RETURNS date AS $$
  SELECT CAST(date_trunc('month', $1 + interval '1month') AS date) - 1;
$$ LANGUAGE sql;

---------8<--------------------------

select 'I''m a string constant';

yerine

select $$I'm a string constant$$;

select $tag$<string_constant>$tag$;

select $$I'm a string constant$$ as message;

SELECT $message$I'm a string constant$message$ s;

---------8<--------------------------

select uuid_extract_version(gen_random_uuid());

---------8<--------------------------

create table tbltest(id int generated always as identity primary key, adi varchar(255), soyadi varchar(255))

explain (buffers , analyze , verbose) select * from tbltest
explain (buffers , analyze , verbose , format yaml) select * from tbltest
explain (buffers , analyze , verbose, wal, format yaml) select * from tbltest;
explain (buffers , analyze , verbose, wal, format json) select * from tbltest;

---------8<--------------------------

Tüm tipleri ve buyutlarını listtelemek için
SELECT typname,typlen from pg_type where typtype='b';

---------8<--------------------------

select row(id , adi , soyadi) from tbltest;
select  row_to_json(row(id , adi , soyadi)) from tbltest;

---------8<--------------------------

Postgresql'de tablo oluştururken verdiğimiz isim lovercase olarak işleniyor,
eğer tablo adının istediğimiz şekilde olmasını istiyorsak
"AAA" şeklinde tırnak içine almalıyız,

Kolonlardada aynısı geçerli,

SELECT foo, FOo, Foo, fOO          -- all fold down to "foo"
SELECT "foo", "FOo", "Foo", "fOO"  -- are all different

---------8<--------------------------

select to_timestamp( '01.02.2014', 'DD.MM.YYYY' );

---------8<--------------------------

BEGIN
        select into howmuch sum(price) from stuff where invoiced='t';
        IF NOT FOUND THEN
                return 0;
        ELSE
                return howmuch;
        ENDIF;
END;

---------8<--------------------------

BEGIN;
        DECLARE cursorname FOR query;
        FETCH number_of_rows FROM cursorname;
        MOVE {FORWARD|BACKWARD} number_of_rows IN cursorname;
        ...
COMMIT;

---------8<--------------------------

A function created with IMMUTABLE means: It will always return the same value for the same input.
A function created with STRICT means : It will not be run if an argument is null.

---------8<--------------------------

eğer sorgumuzda bir sıra numarasına gerek duyuluyorsa,

CREATE TEMP SEQUENCE number;
select adi , soyadi , nextval('number') from tbltest

şeklinde oturumumuzda geçici bir sequence  oluşturuyoruz,

---------8<--------------------------

select current_timestamp => "2014-03-26 09:19:11.273+00"
select localtimestamp => "2014-03-26 09:19:17.894"
select current_date => "2014-03-26"
select current_time => "09:19:31.04+00"
select localtime => "09:19:37.35"
select now() => "2014-03-26 09:19:42.605+00"
select timeofday() => "Wed Mar 26 09:19:48.905000 2014 GMT"

---------8<--------------------------

datetime casting

select now()::date

select timeofday()::timestamp;
select timeofday()::date;
select timeofday()::timestamp::time;

---------8<--------------------------

Trigger fonksiyonları

NEW = Data type RECORD; variable holding the new database row for INSERT/UPDATE operations in row-level triggers. This variable is unassigned in statement-level triggers and for DELETE operations.
OLD = Data type RECORD; variable holding the old database row for UPDATE/DELETE operations in row-level triggers. This variable is unassigned in statement-level triggers and for INSERT operations.
TG_NAME = Data type name; variable that contains the name of the trigger actually fired.
TG_WHEN = Data type text; a string of BEFORE, AFTER, or INSTEAD OF, depending on the trigger's definition.
TG_LEVEL = Data type text; a string of either ROW or STATEMENT depending on the trigger's definition.
TG_OP = Data type text; a string of INSERT, UPDATE, DELETE, or TRUNCATE telling for which operation the trigger was fired.
TG_RELID = Data type oid; the object ID of the table that caused the trigger invocation.
TG_RELNAME = Data type name; the name of the table that caused the trigger invocation. This is now deprecated, and could disappear in a future release. Use TG_TABLE_NAME instead.
TG_TABLE_NAME = Data type name; the name of the table that caused the trigger invocation.
TG_TABLE_SCHEMA = Data type name; the name of the schema of the table that caused the trigger invocation.
TG_NARGS = Data type integer; the number of arguments given to the trigger procedure in the CREATE TRIGGER statement.
TG_ARGV[] = Data type array of text; the arguments from the CREATE TRIGGER statement. The index counts from 0. Invalid indexes (less than 0 or greater than or equal to tg_nargs) result in a null value.

---------8<--------------------------

sorgularda regex kullanımı

~       Matches regular expression, case sensitive
~*      Matches regular expression, case insensitive
!~      Does not match regular expression, case sensitive
!~*     Does not match regular expression, case insensitive


SELECT * FROM table_name WHERE col !~* '^[a-z]'
SELECT * FROM table_name WHERE col !~ '^[a-zA-Z]';

---------8<--------------------------

case kullanımı
SELECT ...
          CASE
            WHEN date < CURRENT_DATE THEN 'green'::text
            WHEN date > CURRENT_DATE THEN 'red'::text
            ELSE 'blue'::text
          END
          AS state,
          (t1.field2 || t2.fieldA) AS stuff
        FROM ...

---------8<--------------------------

select to_hex(10);
select x'ab'::integer;

---------8<--------------------------

SELECT 1 IN (1,2);      t
SELECT 1 NOT IN (1,2);  f
SELECT 1 IN (NULL, 1,2);        t
SELECT 1 NOT IN (NULL,1,2);     f



SELECT 3 IN (1,2);      f
SELECT 3 NOT IN (1,2);  t
SELECT 3 IN (NULL, 1,2);        NULL
SELECT 3 NOT IN (NULL,1,2);     NULL


SELECT NULL IN (1,2);   NULL
SELECT NULL NOT IN (1,2);       NULL
SELECT NULL IN (NULL, 1,2);     NULL
SELECT NULL NOT IN (NULL,1,2);  NULL

---------8<--------------------------

istatistikler

select * from pg_stat_database;
select * from pg_stat_all_tables;
select * from pg_stat_all_indexes;
select * from pg_stat_user_tables;
select * from pg_stat_user_indexes;
select * from pg_stat_sys_tables;
select * from pg_stat_sys_indexes;


io istatistikleri

select * from pg_statio_all_tables
select * from pg_statio_all_indexes
select * from pg_statio_all_sequences
select * from pg_statio_user_tables
select * from pg_statio_user_indexes
select * from pg_statio_user_sequences
select * from pg_statio_sys_tables
select * from pg_statio_sys_indexes
select * from pg_statio_sys_sequences



bağlı olunan veritabanındaki istatistikleri sıfırlıyor,
superuser olarak çalıştırılabiliyor

SELECT pg_stat_reset();

---------8<--------------------------

single user mode

su - postgres
postgres --single -D DBPATH DBNAME

CTRL + D ile çıkılıyor

---------8<--------------------------

select repeat('test'::text, 100);

---------8<--------------------------

psql'de değişken tanımlayıp kullanmak

\set nbranches :scale
\set naccounts 100000 * :scale
\set aid random(1, :naccounts)
\set bid random(1, :nbranches)
BEGIN;
SELECT * FROM pgbench_accounts WHERE aid >= :aid AND aid < (:aid + 5000) AND bid=:bid LIMIT 1;
END;

---------8<--------------------------

psql'de değişken tanımlayıp kullanmak
string değişkenler için :'' gerekiyor

test=> \! echo "test" > tmp.txt
test=> \set my_var `cat tmp.txt`
test=> create table tbltst(a varchar(255));
CREATE TABLE
test=> insert into tbltst values (:'my_var');
INSERT 0 1
test=> select * from tbltst;
  a
------
 test
(1 row)

---------8<--------------------------

konsoldan komut çalıştırmak

psql -At -c "SELECT relname FROM pg_class WHERE oid IN (2608,2610);"

---------8<--------------------------

upsert
insert into aaaa values (40,'dsfgdfsgXXX') on conflict (id) do update set abc = EXCLUDED.abc;

---------8<--------------------------

ON_ERROR_STOP=1

psql -v ON_ERROR_STOP=1 --username "$POSTGRES_USER" <<-EOSQL
    CREATE USER docker;
    CREATE DATABASE docker;
    GRANT ALL PRIVILEGES ON DATABASE docker TO docker;

---------8<--------------------------

postgresql'de bir function returns setof XYZ
seklinde bir tip döndürüyor ise

biz tip'de bir degisiklik yaptigimizda kolon ekleyip cikardigimizda
ör
alter table tbl1 add column b varchar(25);
wrong record type supplied in RETURN NEXT

seklinde bir hata aliriz
oturumu sonlandirip yeniden actigimizda bu hata gider

psql'de

\c -

komutu ile oturumu yeniden acabiliriz

---------8<--------------------------

uptime

SELECT now() - pg_postmaster_start_time();

saniye cinsinden daha mantıklı
select date_trunc('second', current_timestamp - pg_postmaster_start_time()) as "uptime";
select date_trunc('minute', current_timestamp - pg_postmaster_start_time()) as "uptime";

---------8<--------------------------

seriden tablo oluşturmak

create table x as select * from generate_series(1,10000) as a;

---------8<--------------------------

create table tblx (id int generated always as identity primary key, a varchar(25), b varchar(25));

// bu tablonun id alanına insert yada update yapabiliriz
create table tbly (id int generated by default as identity primary key, a varchar(25), b varchar(25));

---------8<--------------------------

create table t2( like t1 including all);

---------8<--------------------------

https://devcenter.heroku.com/articles/heroku-postgres-import-export

şifre'yi env ile vermek için

export PGPASSWORD=mypassword 

pg_dump -Fc --no-acl --no-owner -h localhost -U myuser -d mydb -f mydb.dump

pg_restore --clean --no-acl --no-owner -h localhost -U myuser -d mydb latest.dump

---------8<--------------------------

\timing on
\timing off

yada toggle için
\timing

---------8<--------------------------

\watch 

psql'in bir komutu

select count(*) from tbltest; \watch
varsayılan 2 saniye

select count(*) from tbltest; \watch N
her N saniyede bir çalışır

SELECT * FROM pg_stat_progress_copy \watch 1

yada önce bir sorgu çalıştır
sonra

SELECT * FROM pg_stat_progress_copy

\watch 1
ile en son çalıştırtığımız komutu sürekli çalıştırıyor

---------8<--------------------------

select pg_reload_conf();

restart gerektirmeyen conf değişikliklerini uygular

$ pg_ctl -D $PGDATA reload
Or
$ psql -U postgres -p 5432 -c "select pg_reload_conf()"

---------8<--------------------------

copy performansını görmek için

\copy (
    SELECT i, now() - random() * '2 years'::INTERVAL, random()
    FROM generate_series(1,10000000) i
) TO /dev/null;

---------8<--------------------------

select count(*) ...
ile
select count('x') ...

aynı

---------8<--------------------------

tablo'nun istatistiklerini resetlemek

ilk önce tablonun oid'ini buluyoruz

SELECT oid FROM pg_class c WHERE relname = 'table_name';
XXXX

SELECT pg_stat_reset_single_table_counters(XXXX);

---------8<--------------------------

test=> \set xyz `ls -al /`
test=> select :'xyz';

select string_to_array(:'xyz',' ');
select string_to_array(:'xyz',',')::numeric[];

test=> \set klm `ls /`
test=> select :'klm';
create table tblklmn (id serial , dir varchar(255));
insert into tblklmn values(default,:'klm');

create table iowaits ( day date, iowaits numeric[] );
CREATE TABLE
postgres=# insert into iowaits (day,iowaits) values ( current_date, string_to_array(:'iowait',',')::numeric[] );

---------8<--------------------------

create table t ( id int primary key, name varchar(50), salary bigint );
insert into t ( id, name, salary ) values ( 1,'name1',1000), (2,'name2',20000), (3,'name3',3000);
create user u1 UNENCRYPTED PASSWORD 'u1';
create user u2 UNENCRYPTED PASSWORD 'u2';
grant select (id,name) on t to u1;
grant select (name,salary) on t to u2;

---------8<--------------------------

superuser olmadan csv copy için

create table test (email varchar(255));

dosyanın sonunda boş satır bırakma, onuda kayıt olarak giriyor
eğer ilk satır header ise HEADER kullan

cat list.csv | psql -d test -U user -c "COPY test(email) FROM STDIN CSV HEADER;"

---------8<--------------------------

select context from pg_settings where name = 'work_mem';

---------8<--------------------------

bir tablonun PGDATA'nın altından yolunu gösteriyor

select pg_relation_filepath('tbltest');
pg_relation_filepath
----------------------
 base/24670/24673

---------8<--------------------------

bir view'in definition'ı

select pg_get_viewdef('VIEW_ADI'::regclass, true);

---------8<--------------------------

pg_dump -s -t t1 ddl | egrep -v "^--|^$"

t1 tablosunun definition'ı

---------8<--------------------------

varchar tipindeki kolonu date'e çevirmek

create table t1 ( a varchar(20) );

alter table t1 alter column a type date using to_date(a,'DDMMYYYY');

---------8<--------------------------

sistemden bir rol silmeden silinecek role bağımlı olan nesneleri düşünüp
başka bir role atamak gerekebilir

REASSIGN OWNED BY old_role TO new_role
komutu ile eski role bağlı tüm nesneler yeni nesnenin olur

---------8<--------------------------

bir kullanıcıyı superuser yapmak

create role my_admin;
alter role my_admin superuser;

yada direkt

create role my_admin superuser;

---------8<--------------------------

set role my_admin;

alter user my_dba set role my_admin;

---------8<--------------------------

çalıştırılan tüm sorguları loglamak için

logging_collector = on
log_statement = 'all'

serverlog'a yazıyor

---------8<--------------------------

set search_path = 'my_schema',"$user",public;

---------8<--------------------------

dosyayı tek transaction içinde yapıyor eğer hata olursa rollback ediliyor

psql -1f file.sql

-1 ("one"), --single-transaction
    execute as a single transaction (if non-interactive)

---------8<--------------------------

SELECT char_length('ABCDE')
SELECT character_length('ABCDE')

---------8<--------------------------

psql -h /tmp

ile unix domain socket'e

psql -h localhost

ile tcp ip üzerinden bağlantı yapılıyor

---------8<--------------------------

bir sorgu dosyadan çalıştırılırken ne kadar zamanda çalıştı

psql -c "SELECT current_time" –f examples.sql -c "SELECT current_time"

---------8<--------------------------

CREATE TABLE uses_identity (
   id bigint GENERATED ALWAYS AS IDENTITY
             (MINVALUE 0 START WITH 0 CACHE 20)
             PRIMARY KEY,
   ...
);

---------8<--------------------------

1 ay sonraki tarih

select current_timestamp +  interval '1 month';

buradaki interval
hours
second

olabilir

---------8<--------------------------

MySQL'deki

SELECT FROM_UNIXTIME(timecreated) ...
SELECT from_unixtime(timecreated) ...

SELECT FROM_UNIXTIME(UNIX_TIMESTAMP(), '%Y %D %M %h:%i:%s %x');
+---------------------------------------------------------+
| FROM_UNIXTIME(UNIX_TIMESTAMP(), '%Y %D %M %h:%i:%s %x') |
+---------------------------------------------------------+
| 2025 30th September 09:04:42 2025                       |
+---------------------------------------------------------+


yerine PostgreSQL'de

SELECT to_timestamp(timecreated) ....

kullanabiliriz

SELECT extract('epoch' from CURRENT_TIMESTAMP)::bigint;
SELECT extract('epoch' from now())::bigint;

ile tarihi bigint'e yani unixtime'a çevirebiliriz

SELECT to_timestamp(extract('epoch' from now())::bigint);

istediğimiz bir tarihi unix time'a çevirmek

select extract('epoch' from '2021-01-01 00:00:00+00'::timestamp)::bigint;
select extract('epoch' from '2021-01-01'::timestamp)::bigint;
select extract('epoch' from '2021-12-20'::timestamp)::bigint;

kontrol için

SELECT to_timestamp(extract('epoch' from now())::bigint);

---------8<--------------------------

select decode('1234','base64');
select encode ('\xd76df8','base64');

select decode('1234','hex');
select encode('\x1234','hex');

---------8<--------------------------

https://dba.stackexchange.com/questions/125413/index-not-used-with-any-but-used-with-in/125500#125500

SELECT *
FROM t
WHERE (a,b) = ANY(VALUES (1,1),(1,2));

...
WHERE (a,b) IN (VALUES (1,1),(1,2));

---------8<--------------------------

postgresql.conf dosyasında work_mem küçük tutulup eğer
çalıştıracağımız sorgu daha fazla ram'e ihtiyaç duyuyorsa
SET LOCAL ile query başına set edebiliriz

SET LOCAL work_mem = '64MB';
SELECT * FROM db ORDER BY LOWER(name);

---------8<--------------------------

sadece bilgi için

regex mantığı

DECLARE
    current_timescaledb_version_full    VARCHAR;
begin

SHOW server_version INTO current_postgres_version_full;

IF NOT found THEN
RAISE EXCEPTION 'Cannot determine PostgreSQL version, aborting';
END IF;

SELECT substring(current_postgres_version_full, '^(\d+).') INTO current_postgres_version_major;
SELECT substring(current_postgres_version_full, '^\d+.(\d+)') INTO current_postgres_version_minor;

---------8<--------------------------

create table t2 ( a text compression LZ4 );
create table t3 ( a varchar(255) compression LZ4 );

---------8<--------------------------

SELECT (timestamp at time zone 'australia/perth')::date, COUNT(*)
FROM sale
GROUP BY 1; 

---------8<--------------------------

ALTER TABLE tbl ADD CONSTRAINT tbl_column_fk
FOREIGN KEY (tbl_column) REFERENCES diğer_tablo(kolon);

---------8<--------------------------

değişiklik yapılmış satırlar

grep '^[[:blank:]]*[^[:blank:]#;]' /etc/postgresql/18/main/postgresql.conf

---------8<--------------------------

admin kullanıcısı olarak

select * from pg_file_settings;
yada
table pg_file_settings;

ile postgresql.conf dosyasındaki varsayılanın dışında değişiklikleri görebiliriz,

---------8<--------------------------

psql'de şemaları listelemek

=> \dnS
        List of schemas
        Name        |  Owner
--------------------+----------
 information_schema | postgres
 pg_catalog         | postgres
 pg_toast           | postgres
 public             | postgres

---------8<--------------------------

SELECT substring('w3resource' from 4 for 5);

The following PostgreSQL statement returns 5 characters starting from the 4th position from the string 'w3resource', that is 'esour'.

substring(first_name,1,4) "1st 4 characters of first_name"

---------8<--------------------------

CREATE USER: varsayılan olarak login yetkisi olan bir kullanıcı oluşturur.
CREATE ROLE: nologin bir kullanıcı oluşturur.

---------8<--------------------------

listen_addresses = ''

ile tcp/ip'yi kapatıyoruz

---------8<--------------------------

env PGOPTIONS="-c geqo=off -c statement_timeout=5min" psql

---------8<--------------------------

ALTER ROLE postgres NOSUPERUSER;

ile postgres kullanıcısının superuser yetkileri alınıyor,

ALTER ROLE postgres SUPERUSER;
ERROR:  must be superuser to alter superuser roles or change superuser attribute
ile'de veremiyoruz !,

---------8<--------------------------

single user mod

sudo -u postgres bash

/usr/lib/postgresql/18/bin/postgres --single -D /var/lib/postgresql/18/main/ -c config_file=/etc/postgresql/18/main/postgresql.conf  postgres

backend>

açılıyor

backend> ALTER ROLE postgres SUPERUSER
backend> CTRL + D

---------8<--------------------------

generate_series(1,16,2)
1'den 16'ya kadar 2 şer ikişer
1,3,5,7,9,11,13,15

---------8<--------------------------

https://stackoverflow.com/questions/12815496/export-specific-rows-from-a-postgresql-table-as-insert-sql-script/12816187#12816187

Export specific rows from a PostgreSQL table as INSERT SQL script

create table export_table as
select id, name, city
from nyummy.cimory
where city = 'tokyo'

$ pg_dump --table=export_table --data-only --column-inserts my_database > data.sql

--column-inserts will dump as insert commands with column names.

--data-only do not dump schema.

---------8<--------------------------

oturum için değişken tanımlama

SET session total.users = 200;
select id from generate_series(1, current_setting('total.users')::INTEGER) id;

---------8<--------------------------

select exists(SELECT 1 from pg_database WHERE datname = 'test')

true yada false dönmesi istediğimiz bir sorgu için

if the subquery returns NULL, EXISTS returns true. See the following example:

select exists(SELECT NULL);

---------8<--------------------------

SELECT format('GRANT SELECT ON TABLE %I TO someuser;', tablename) FROM pg_tables WHERE tablename~'^pgbench';

---------8<--------------------------

-- sanıyorum bu şekilde trigger'ı tetikleyebiliyoruz

update iot_thermostat set thetime=thetime;

update table set colon = colon

---------8<--------------------------

replication != yedek,backup

---------8<--------------------------

varsayılan değerleri girmek için

create table t1 (id serial primary key, a varchar(255));
insert into t1 default values;

DEFAULT VALUES

create table t1x (id int generated always as identity primary key, a varchar(255));
insert into t1x default values;

---------8<--------------------------

identity kolonun değerini değiştirmek için

insert into t2 (id) overriding system value values (1);

---------8<--------------------------

a VARCHAR domain that should have a not null constraint and a default value of 'N/A'.

CREATE DOMAIN addr VARCHAR(90) NOT NULL DEFAULT 'N/A';

---------8<--------------------------

USING keyword

The USING clause is a shorthand that allows you to take advantage of the specific situation where both sides of the join use the same name for the joining column(s). It takes a comma-separated list of the shared column names and forms a join condition that includes an equality comparison for each one. For example, joining T1 and T2 with USING (a, b) produces the join condition ON T1.a = T2.a AND T1.b = T2.b.

---------8<--------------------------

psql -v ON_ERROR_STOP=1 -d MYDB -U MYUSER < dump.sql

---------8<--------------------------

local'de şifre sormasını istersek

pg_hba.conf

local   all             all   trust
=>
local   all             all   md5

---------8<--------------------------

tcp portu 5432 üzerinden değil socket üzerinden bağlanmak istersek
psql -h /tmp -d postgres -U postgres


psql -h /var/run/postgresql -d your_database

socket path'i dbadmin olarak

show unix_socket_directories;

görebiliriz

unix_socket_directories = '/var/run/postgresql, /tmp'

ile iki farklı şekilde tanımlayabiliriz

psql -U postgres -p 5432 -h /var/run/postgresql

psql -U user -d postgres -h /var/run/postgresql

---------8<--------------------------

not null'u kaldırmak

alter table tbltest alter column tblcol drop not null;

---------8<--------------------------
şifre sormadan cron çalıştırma

export EDITOR=vim
crontab -e -u postgres

PGPASSWORD='secret'

0 4 * * * /opt/pgsql/16_0/bin/vacuumdb --all -U postgres --analyze -j 4

---------8<--------------------------

şifre sormadan backup alma

#!/bin/sh

DATE=$(date +%d_%m_%Y_%H%M)
BACKUP_DIR=/backup/postgresql
export PGPASSWORD=secret

/usr/local/bin/pg_dump -Fc -h 192.168.10.1 -d test -U kullanici > $BACKUP_DIR/test_$DATE.dump

---------8<--------------------------

https://www.percona.com/blog/2018/08/29/tune-linux-kernel-parameters-for-postgresql-optimization/

PostgreSQL için ne kadar huge page'in gerektiği

#!/bin/bash
pid=`head -1 $PGDATA/postmaster.pid`
echo "Pid:            $pid"
peak=`grep ^VmPeak /proc/$pid/status | awk '{ print $2 }'`
echo "VmPeak:            $peak kB"
hps=`grep ^Hugepagesize /proc/meminfo | awk '{ print $2 }'`
echo "Hugepagesize:   $hps kB"
hp=$((peak/hps))
echo Set Huge Pages:     $hp

---------8<--------------------------

tırnak içinde sonuç dönülmesi için

SELECT  format( '"%s"', email ) from emails;

---------8<--------------------------

iki tablonun diff'i

select * from h201 where not exists (select from h201_l where h201.email = h201_l.email);
select id from m where not exists (select id from a where a.id = m.id);

---------8<--------------------------

psql ile stdin'den toplu veri girişi

=> create table x (id varchar(255));
=> copy m from stdin;
Enter data to be copied followed by a newline.
End with a backslash and a period on a line by itself, or an EOF signal.
>> 12344
45645
325345
435646
345645
\. yada CTRL+D

---------8<--------------------------

tablodaki veriyi stdout'a kopyalamak

COPY (select * from m) TO STDOUT;

---------8<--------------------------

psql'de sorgulara parametre eklenebiliyor

psql
> select count(*) from pg_class where relkind=$1 and relname not like $2
> \bind 'r' 'pg_%'
> \g

---------8<--------------------------

select current_user, system_user;

---------8<--------------------------

pg_hba.conf'ta regex kullanımı

host /^dev /^dev 10.0.0.0/24 scram-sha-2564
host sameuser /^test 10.0.0.0/24 scram-sha-2564

---------8<--------------------------

pg_hba.conf'ta

include_if_exists pg_hba_override.conf
include pg_hba_test.conf
include_dir all_my_pghba

---------8<--------------------------

grant maintain on mytable to testuser;
grant pg_maintain to testuser;

---------8<--------------------------

... ORDER BY last_updated NULLS FIRST

... ORDER BY last_updated DESC NULLS LAST

CREATE INDEX foo_idx ON tbl (last_updated DESC NULLS LAST);

CREATE INDEX foo_idx ON tbl (last_updated);

NULLS FIRST is default for DESC, NULLS LAST is default for ASC.

---------8<--------------------------

pg_dump için

-Z gzip:9
-Z lz4:9

gibi farklı sıkıştırma kütüphaneleri seçilebilir

---------8<--------------------------

template0 should never be modified, but you can add objects to template1, which by default will be copied into databases created later.

---------8<--------------------------

GRANT SELECT ON ALL TABLES IN SCHEMA public TO user;
GRANT EXECUTE ON ALL FUNCTIONS IN SCHEMA public TO user;

---------8<--------------------------

ps -u postgres -o pid,comm,cmd,args

---------8<--------------------------

create role paperwork;
create database paperwork;
grant all privileges on database paperwork to paperwork;
ALTER ROLE paperwork WITH LOGIN;
ALTER ROLE paperwork WITH PASSWORD 'paperwork';

---------8<--------------------------

CREATE USER rewind_user LOGIN;
GRANT EXECUTE ON function pg_catalog.pg_ls_dir(text, boolean, boolean) TO rewind_user;
GRANT EXECUTE ON function pg_catalog.pg_stat_file(text, boolean) TO rewind_user;
GRANT EXECUTE ON function pg_catalog.pg_read_binary_file(text) TO rewind_user;
GRANT EXECUTE ON function pg_catalog.pg_read_binary_file(text, bigint, bigint, boolean) TO rewind_user;

---------8<--------------------------

GRANT ALTER SYSTEM ON PARAMETER cpu_index_tuple_cost TO test_user;

---------8<--------------------------

MERGE INTO customer_account ca
USING recent_transactions t
ON t.customer_id = ca.customer_id
WHEN MATCHED THEN
UPDATE SET balance = balance + transaction_value
WHEN NOT MATCHED THEN
INSERT (customer_id, balance)
VALUES (t.customer_id, t.transaction_value);

---------8<--------------------------

bir tabloya primary key eklemek
alter table customers add primary key (id);

create table y (id int);
alter table y alter id set not null, alter id add generated always as identity;

eğer tabloda veri varsa

 (START WITH 2);

ile identity'nin kaçıncı kolondan başlayacağını belirleyebiliriz

---------8<--------------------------

işletim sistemi ve postgresql servisinin limitlerini görmek

https://unix.stackexchange.com/questions/480574/how-do-i-identify-all-of-the-configured-memory-limits-for-a-service-started-usin

systemctl show postgresql.service | grep ^Memory
systemctl show postgresql.service | grep ^Limit

ipcs -ma
lsipc

---------8<--------------------------

revoke all on schema public from public;

---------8<--------------------------

kullanıcı bazlı kaynak ayarlama

create role xyz password 'deneme' login connection limit 5;
alter role xyz set work_mem = '10MB';
alter role xyz reset work_mem;

pg_user.userconfig
kolonunda tutuyor

---------8<--------------------------

eğer postgresql.conf dosyasının konumunu bilmiyorsak

psql -U postgres -c 'SHOW config_file'

data dizini cluster'ın path'ini

psql -U postgres -c 'SHOW data_directory'

ile öğrenebiliriz

---------8<--------------------------

psql'de
-W
ile illede şifre sor diyoruz,
normalde sormasa bile -W ile soruyor
şifresiz bağlanabildiğimiz halde
şifreyi teyit edebiliriz
ama pg_hba.conf'da trust ise yanlış şifre bile girilse girilebiliyor

---------8<--------------------------

identleri md5
peerleri trust yapmak

sudo sed -i '/^host/s/ident/md5/' /etc/postgresql/16/main/pg_hba.conf
sudo sed -i '/^local/s/peer/trust/' /etc/postgresql/16/main/pg_hba.conf

---------8<--------------------------

select * from pg_shmem_allocations;
shared memory'de ne var

select * from pg_stat_progress_analyze ;
analyze işlemi varsa durumu

select * from pg_stat_progress_basebackup;
basebackup'ın durumu

select * from pg_stat_slru;
simple least-recently-used cache durumu

---------8<--------------------------

---------8<--------------------------