--bad
DECLARE v varchar;
BEGIN
  v := 'a';
  v := v || 'b';
  v := v || 'c';
  RETURN v;
END;

--well
BEGIN
  RETURN 'a' || 'b' || 'c';
END;

---------8<--------------------------

-- bad
DECLARE s varchar := '';
BEGIN
  IF x1 IS NULL THEN
    s := s || 'NULL,'
  ELSE
    s := s || x1;
  END IF;

  IF x2 IS NULL THEN
    s := s || 'NULL, '
  ELSE
    s := s || x2;
  END IF;
  ...

-- well
DECLARE s varchar;
BEGIN
  s := COALESCE(x1 || ',', 'NULL,')
       || COALESCE(x2 || ',', 'NULL,')
  ...

---------8<--------------------------

--bad
CREATE OR REPLACE FUNCTION last_day(IN d date)
RETURNS date AS $$
BEGIN
  RETURN CAST(date_trunc('month',current_date + interval '1month') AS date) - 1;
END;
$$ LANGUAGE plpgsql IMMUTABLE STRICT;

--well
CREATE OR REPLACE FUNCTION last_day(IN d date)
RETURNS date AS $$
  SELECT CAST(date_trunc('month', $1 + interval '1month') AS date) - 1;
$$ LANGUAGE sql;

---------8<--------------------------

select 'I''m a string constant';

yerine

select $$I'm a string constant$$;

select $tag$<string_constant>$tag$;

select $$I'm a string constant$$ as message;

SELECT $message$I'm a string constant$message$ s;

---------8<--------------------------

select uuid_extract_version(gen_random_uuid());

---------8<--------------------------

create table tbltest(id int generated always as identity primary key, adi varchar(255), soyadi varchar(255))

explain (buffers , analyze , verbose) select * from tbltest
explain (buffers , analyze , verbose , format yaml) select * from tbltest
explain (buffers , analyze , verbose, wal, format yaml) select * from tbltest;
explain (buffers , analyze , verbose, wal, format json) select * from tbltest;

---------8<--------------------------

Tüm tipleri ve buyutlarını listtelemek için
SELECT typname,typlen from pg_type where typtype='b';

---------8<--------------------------

select row(id , adi , soyadi) from tbltest;
select  row_to_json(row(id , adi , soyadi)) from tbltest;

---------8<--------------------------

Postgresql'de tablo oluştururken verdiğimiz isim lovercase olarak işleniyor,
eğer tablo adının istediğimiz şekilde olmasını istiyorsak
"AAA" şeklinde tırnak içine almalıyız,

Kolonlardada aynısı geçerli,

SELECT foo, FOo, Foo, fOO          -- all fold down to "foo"
SELECT "foo", "FOo", "Foo", "fOO"  -- are all different

---------8<--------------------------

select to_timestamp( '01.02.2014', 'DD.MM.YYYY' );

---------8<--------------------------

BEGIN
        select into howmuch sum(price) from stuff where invoiced='t';
        IF NOT FOUND THEN
                return 0;
        ELSE
                return howmuch;
        ENDIF;
END;

---------8<--------------------------

BEGIN;
        DECLARE cursorname FOR query;
        FETCH number_of_rows FROM cursorname;
        MOVE {FORWARD|BACKWARD} number_of_rows IN cursorname;
        ...
COMMIT;

---------8<--------------------------

A function created with IMMUTABLE means: It will always return the same value for the same input.
A function created with STRICT means : It will not be run if an argument is null.

---------8<--------------------------

eğer sorgumuzda bir sıra numarasına gerek duyuluyorsa,

CREATE TEMP SEQUENCE number;
select adi , soyadi , nextval('number') from tbltest

şeklinde oturumumuzda geçici bir sequence  oluşturuyoruz,

---------8<--------------------------

select current_timestamp => "2014-03-26 09:19:11.273+00"
select localtimestamp => "2014-03-26 09:19:17.894"
select current_date => "2014-03-26"
select current_time => "09:19:31.04+00"
select localtime => "09:19:37.35"
select now() => "2014-03-26 09:19:42.605+00"
select timeofday() => "Wed Mar 26 09:19:48.905000 2014 GMT"

---------8<--------------------------

datetime casting

select now()::date

select timeofday()::timestamp;
select timeofday()::date;
select timeofday()::timestamp::time;

---------8<--------------------------

Trigger fonksiyonları

NEW = Data type RECORD; variable holding the new database row for INSERT/UPDATE operations in row-level triggers. This variable is unassigned in statement-level triggers and for DELETE operations.
OLD = Data type RECORD; variable holding the old database row for UPDATE/DELETE operations in row-level triggers. This variable is unassigned in statement-level triggers and for INSERT operations.
TG_NAME = Data type name; variable that contains the name of the trigger actually fired.
TG_WHEN = Data type text; a string of BEFORE, AFTER, or INSTEAD OF, depending on the trigger's definition.
TG_LEVEL = Data type text; a string of either ROW or STATEMENT depending on the trigger's definition.
TG_OP = Data type text; a string of INSERT, UPDATE, DELETE, or TRUNCATE telling for which operation the trigger was fired.
TG_RELID = Data type oid; the object ID of the table that caused the trigger invocation.
TG_RELNAME = Data type name; the name of the table that caused the trigger invocation. This is now deprecated, and could disappear in a future release. Use TG_TABLE_NAME instead.
TG_TABLE_NAME = Data type name; the name of the table that caused the trigger invocation.
TG_TABLE_SCHEMA = Data type name; the name of the schema of the table that caused the trigger invocation.
TG_NARGS = Data type integer; the number of arguments given to the trigger procedure in the CREATE TRIGGER statement.
TG_ARGV[] = Data type array of text; the arguments from the CREATE TRIGGER statement. The index counts from 0. Invalid indexes (less than 0 or greater than or equal to tg_nargs) result in a null value.

---------8<--------------------------

sorgularda regex kullanımı

~       Matches regular expression, case sensitive
~*      Matches regular expression, case insensitive
!~      Does not match regular expression, case sensitive
!~*     Does not match regular expression, case insensitive


SELECT * FROM table_name WHERE col !~* '^[a-z]'
SELECT * FROM table_name WHERE col !~ '^[a-zA-Z]';

---------8<--------------------------

case kullanımı
SELECT ...
          CASE
            WHEN date < CURRENT_DATE THEN 'green'::text
            WHEN date > CURRENT_DATE THEN 'red'::text
            ELSE 'blue'::text
          END
          AS state,
          (t1.field2 || t2.fieldA) AS stuff
        FROM ...

---------8<--------------------------

select to_hex(10);
select x'ab'::integer;

---------8<--------------------------

SELECT 1 IN (1,2);      t
SELECT 1 NOT IN (1,2);  f
SELECT 1 IN (NULL, 1,2);        t
SELECT 1 NOT IN (NULL,1,2);     f



SELECT 3 IN (1,2);      f
SELECT 3 NOT IN (1,2);  t
SELECT 3 IN (NULL, 1,2);        NULL
SELECT 3 NOT IN (NULL,1,2);     NULL


SELECT NULL IN (1,2);   NULL
SELECT NULL NOT IN (1,2);       NULL
SELECT NULL IN (NULL, 1,2);     NULL
SELECT NULL NOT IN (NULL,1,2);  NULL

---------8<--------------------------

istatistikler

select * from pg_stat_database;
select * from pg_stat_all_tables;
select * from pg_stat_all_indexes;
select * from pg_stat_user_tables;
select * from pg_stat_user_indexes;
select * from pg_stat_sys_tables;
select * from pg_stat_sys_indexes;


io istatistikleri

select * from pg_statio_all_tables
select * from pg_statio_all_indexes
select * from pg_statio_all_sequences
select * from pg_statio_user_tables
select * from pg_statio_user_indexes
select * from pg_statio_user_sequences
select * from pg_statio_sys_tables
select * from pg_statio_sys_indexes
select * from pg_statio_sys_sequences



bağlı olunan veritabanındaki istatistikleri sıfırlıyor,
superuser olarak çalıştırılabiliyor

SELECT pg_stat_reset();

---------8<--------------------------

single user mode

su - postgres
postgres --single -D DBPATH DBNAME

CTRL + D ile çıkılıyor

---------8<--------------------------

select repeat('test'::text, 100);

---------8<--------------------------

psql'de değişken tanımlayıp kullanmak

\set nbranches :scale
\set naccounts 100000 * :scale
\set aid random(1, :naccounts)
\set bid random(1, :nbranches)
BEGIN;
SELECT * FROM pgbench_accounts WHERE aid >= :aid AND aid < (:aid + 5000) AND bid=:bid LIMIT 1;
END;

---------8<--------------------------

psql'de değişken tanımlayıp kullanmak
string değişkenler için :'' gerekiyor

test=> \! echo "test" > tmp.txt
test=> \set my_var `cat tmp.txt`
test=> create table tbltst(a varchar(255));
CREATE TABLE
test=> insert into tbltst values (:'my_var');
INSERT 0 1
test=> select * from tbltst;
  a
------
 test
(1 row)

---------8<--------------------------

konsoldan komut çalıştırmak

psql -At -c "SELECT relname FROM pg_class WHERE oid IN (2608,2610);"

---------8<--------------------------

upsert
insert into aaaa values (40,'dsfgdfsgXXX') on conflict (id) do update set abc = EXCLUDED.abc;

---------8<--------------------------

ON_ERROR_STOP=1

psql -v ON_ERROR_STOP=1 --username "$POSTGRES_USER" <<-EOSQL
    CREATE USER docker;
    CREATE DATABASE docker;
    GRANT ALL PRIVILEGES ON DATABASE docker TO docker;

---------8<--------------------------

postgresql'de bir function returns setof XYZ
seklinde bir tip döndürüyor ise

biz tip'de bir degisiklik yaptigimizda kolon ekleyip cikardigimizda
ör
alter table tbl1 add column b varchar(25);
wrong record type supplied in RETURN NEXT

seklinde bir hata aliriz
oturumu sonlandirip yeniden actigimizda bu hata gider

psql'de

\c -

komutu ile oturumu yeniden acabiliriz

---------8<--------------------------

uptime

SELECT now() - pg_postmaster_start_time();

saniye cinsinden daha mantıklı
select date_trunc('second', current_timestamp - pg_postmaster_start_time()) as "uptime";
select date_trunc('minute', current_timestamp - pg_postmaster_start_time()) as "uptime";

---------8<--------------------------

seriden tablo oluşturmak

create table x as select * from generate_series(1,10000) as a;

---------8<--------------------------

create table tblx (id int generated always as identity primary key, a varchar(25), b varchar(25));

// bu tablonun id alanına insert yada update yapabiliriz
create table tbly (id int generated by default as identity primary key, a varchar(25), b varchar(25));

---------8<--------------------------

create table t2( like t1 including all);

---------8<--------------------------

https://devcenter.heroku.com/articles/heroku-postgres-import-export

şifre'yi env ile vermek için

export PGPASSWORD=mypassword 

pg_dump -Fc --no-acl --no-owner -h localhost -U myuser -d mydb -f mydb.dump

pg_restore --clean --no-acl --no-owner -h localhost -U myuser -d mydb latest.dump

---------8<--------------------------

\timing on
\timing off

yada toggle için
\timing

---------8<--------------------------

\watch 

psql'in bir komutu

select count(*) from tbltest; \watch
varsayılan 2 saniye

select count(*) from tbltest; \watch N
her N saniyede bir çalışır

SELECT * FROM pg_stat_progress_copy \watch 1

yada önce bir sorgu çalıştır
sonra

SELECT * FROM pg_stat_progress_copy

\watch 1
ile en son çalıştırtığımız komutu sürekli çalıştırıyor

---------8<--------------------------

select pg_reload_conf();

restart gerektirmeyen conf değişikliklerini uygular

$ pg_ctl -D $PGDATA reload
Or
$ psql -U postgres -p 5432 -c "select pg_reload_conf()"

---------8<--------------------------

copy performansını görmek için

\copy (
    SELECT i, now() - random() * '2 years'::INTERVAL, random()
    FROM generate_series(1,10000000) i
) TO /dev/null;

---------8<--------------------------

select count(*) ...
ile
select count('x') ...

aynı

---------8<--------------------------

tablo'nun istatistiklerini resetlemek

ilk önce tablonun oid'ini buluyoruz

SELECT oid FROM pg_class c WHERE relname = 'table_name';
XXXX

SELECT pg_stat_reset_single_table_counters(XXXX);

---------8<--------------------------

test=> \set xyz `ls -al /`
test=> select :'xyz';

select string_to_array(:'xyz',' ');
select string_to_array(:'xyz',',')::numeric[];

test=> \set klm `ls /`
test=> select :'klm';
create table tblklmn (id serial , dir varchar(255));
insert into tblklmn values(default,:'klm');

create table iowaits ( day date, iowaits numeric[] );
CREATE TABLE
postgres=# insert into iowaits (day,iowaits) values ( current_date, string_to_array(:'iowait',',')::numeric[] );

---------8<--------------------------

create table t ( id int primary key, name varchar(50), salary bigint );
insert into t ( id, name, salary ) values ( 1,'name1',1000), (2,'name2',20000), (3,'name3',3000);
create user u1 UNENCRYPTED PASSWORD 'u1';
create user u2 UNENCRYPTED PASSWORD 'u2';
grant select (id,name) on t to u1;
grant select (name,salary) on t to u2;

---------8<--------------------------

superuser olmadan csv copy için

create table test (email varchar(255));

dosyanın sonunda boş satır bırakma, onuda kayıt olarak giriyor
eğer ilk satır header ise HEADER kullan

cat list.csv | psql -d test -U user -c "COPY test(email) FROM STDIN CSV HEADER;"

---------8<--------------------------

select context from pg_settings where name = 'work_mem';

---------8<--------------------------

bir tablonun PGDATA'nın altından yolunu gösteriyor

select pg_relation_filepath('tbltest');
pg_relation_filepath
----------------------
 base/24670/24673

---------8<--------------------------

bir view'in definition'ı

select pg_get_viewdef('VIEW_ADI'::regclass, true);

---------8<--------------------------

pg_dump -s -t t1 ddl | egrep -v "^--|^$"

t1 tablosunun definition'ı

---------8<--------------------------

varchar tipindeki kolonu date'e çevirmek

create table t1 ( a varchar(20) );

alter table t1 alter column a type date using to_date(a,'DDMMYYYY');

---------8<--------------------------

sistemden bir rol silmeden silinecek role bağımlı olan nesneleri düşünüp
başka bir role atamak gerekebilir

REASSIGN OWNED BY old_role TO new_role
komutu ile eski role bağlı tüm nesneler yeni nesnenin olur

---------8<--------------------------

bir kullanıcıyı superuser yapmak

create role my_admin;
alter role my_admin superuser;

yada direkt

create role my_admin superuser;

---------8<--------------------------

set role my_admin;

alter user my_dba set role my_admin;

---------8<--------------------------

çalıştırılan tüm sorgulamak istersek

set log_statement='all';

---------8<--------------------------

set search_path = 'my_schema',"$user",public;

---------8<--------------------------

dosyayı tek transaction içinde yapıyor eğer hata olursa rollback ediliyor

psql -1f file.sql

-1 ("one"), --single-transaction
    execute as a single transaction (if non-interactive)

---------8<--------------------------

SELECT char_length('ABCDE')
SELECT character_length('ABCDE')

---------8<--------------------------

psql -h /tmp

ile unix domain socket'e

psql -h localhost

ile tcp ip üzerinden bağlantı yapılıyor

---------8<--------------------------

bir sorgu dosyadan çalıştırılırken ne kadar zamanda çalıştı

psql -c "SELECT current_time" –f examples.sql -c "SELECT current_time"

---------8<--------------------------

CREATE TABLE uses_identity (
   id bigint GENERATED ALWAYS AS IDENTITY
             (MINVALUE 0 START WITH 0 CACHE 20)
             PRIMARY KEY,
   ...
);

---------8<--------------------------

1 ay sonraki tarih

select current_timestamp +  interval '1 month';

buradaki interval
hours
second

olabilir

---------8<--------------------------

MySQL'deki

SELECT FROM_UNIXTIME(timecreated) ...
SELECT from_unixtime(timecreated) ...

SELECT FROM_UNIXTIME(UNIX_TIMESTAMP(), '%Y %D %M %h:%i:%s %x');
+---------------------------------------------------------+
| FROM_UNIXTIME(UNIX_TIMESTAMP(), '%Y %D %M %h:%i:%s %x') |
+---------------------------------------------------------+
| 2025 30th September 09:04:42 2025                       |
+---------------------------------------------------------+


yerine PostgreSQL'de

SELECT to_timestamp(timecreated) ....

kullanabiliriz

SELECT extract('epoch' from CURRENT_TIMESTAMP)::bigint;
SELECT extract('epoch' from now())::bigint;

ile tarihi bigint'e yani unixtime'a çevirebiliriz

SELECT to_timestamp(extract('epoch' from now())::bigint);

istediğimiz bir tarihi unix time'a çevirmek

select extract('epoch' from '2021-01-01 00:00:00+00'::timestamp)::bigint;
select extract('epoch' from '2021-01-01'::timestamp)::bigint;
select extract('epoch' from '2021-12-20'::timestamp)::bigint;

kontrol için

SELECT to_timestamp(extract('epoch' from now())::bigint);

---------8<--------------------------

select decode('1234','base64');
select encode ('\xd76df8','base64');

select decode('1234','hex');
select encode('\x1234','hex');

---------8<--------------------------

https://dba.stackexchange.com/questions/125413/index-not-used-with-any-but-used-with-in/125500#125500

SELECT *
FROM t
WHERE (a,b) = ANY(VALUES (1,1),(1,2));

...
WHERE (a,b) IN (VALUES (1,1),(1,2));

---------8<--------------------------

postgresql.conf dosyasında work_mem küçük tutulup eğer
çalıştıracağımız sorgu daha fazla ram'e ihtiyaç duyuyorsa
SET LOCAL ile query başına set edebiliriz

SET LOCAL work_mem = '64MB';
SELECT * FROM db ORDER BY LOWER(name);

---------8<--------------------------

sadece bilgi için

regex mantığı

DECLARE
    current_timescaledb_version_full    VARCHAR;
begin

SHOW server_version INTO current_postgres_version_full;

IF NOT found THEN
RAISE EXCEPTION 'Cannot determine PostgreSQL version, aborting';
END IF;

SELECT substring(current_postgres_version_full, '^(\d+).') INTO current_postgres_version_major;
SELECT substring(current_postgres_version_full, '^\d+.(\d+)') INTO current_postgres_version_minor;

---------8<--------------------------

create table t2 ( a text compression LZ4 );
create table t3 ( a varchar(255) compression LZ4 );

---------8<--------------------------

SELECT (timestamp at time zone 'australia/perth')::date, COUNT(*)
FROM sale
GROUP BY 1; 

---------8<--------------------------